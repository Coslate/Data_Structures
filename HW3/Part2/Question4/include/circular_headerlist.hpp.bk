//circular_headerlist.hpp
#include <circular_headerlist.h>
#include <cstdlib>

template <typename CoefType, typename ExpType>
CHLNode<CoefType, ExpType>* CircularHeaderList<CoefType, ExpType>::GetNode(){
    CHLNode<CoefType, ExpType> *x;
    if(av){
        x = av;
        av = av->link;
    }else{
        CoefType unknown_coef;
        ExpType unknown_exp;
        x = new CHLNode<CoefType, ExpType> (unknown_coef, unknown_exp, NULL);
    }

    return x;
}

template <typename CoefType, typename ExpType>
void  CircularHeaderList<CoefType, ExpType>::RetNode(CHLNode<CoefType, ExpType> *&x){
    x->link = av;
    av      = x;
    x       = NULL;
}

template <typename CoefType, typename ExpType>
void  CircularHeaderList<CoefType, ExpType>::CleanAV(){
    while(av!=NULL){
        CHLNode<CoefType, ExpType> tmp_nxt = av->link;
        av->link = NULL;
        delete av;
        av = tmp_nxt;
    }
}

template <typename CoefType, typename ExpType>
void CircularHeaderList<CoefType, ExpType>::InsertFront(const CoefType &in_coef, const ExpType &in_exp){
    CHLNode<CoefType, ExpType> *new_node = GetNode();
    new_node->coef   = in_coef;
    new_node->exp    = in_exp;
    new_node->link   = header->link;
    header->link = new_node;
}

template <typename CoefType, typename ExpType>
void CircularHeaderList<CoefType, ExpType>::InsertBack(const CoefType &in_coef, const ExpType &in_exp){
    CHLNode<CoefType, ExpType> *last_node = header->link;
    //Find the last node
    while(last_node->link != header){
        last_node = last_node->link;
    }
    CHLNode<CoefType, ExpType> *new_node = GetNode();
    new_node->coef   = in_coef;
    new_node->exp    = in_exp;
    new_node->link   = header;
    last_node->link  = new_node;
}

template <typename CoefType, typename ExpType>
void CircularHeaderList<CoefType, ExpType>::DeleteFirst(){
    if(IsEmpty()){
        throw std::runtime_error(std::string("Warning: CircularHeaderList "+name+" is empty. Cannot DeleteFirst()."));
    }

    CHLNode<CoefType, ExpType> *first_node = header->link;
    header->link = first_node->link;
    RetNode(first_node);
}

template <typename CoefType, typename ExpType>
void CircularHeaderList<CoefType, ExpType>::DeleteLast(){
    if(IsEmpty()){
        throw std::runtime_error(std::string("Warning: CircularHeaderList "+name+" is empty. Cannot DeleteLast()."));
    }

    CHLNode<CoefType, ExpType> *current_node = header->link;
    CHLNode<CoefType, ExpType> *prev_node    = header;
    //Find the last node
    while(current_node->link != header){
        prev_node = current_node;
        current_node = current_node->link;
    }

    prev_node->link = current_node->link;
    RetNode(current_node);
}

template <typename CoefType, typename ExpType>
CHLNode<CoefType, ExpType>* CircularHeaderList<CoefType, ExpType>::Get(const int i) const{
    if(IsEmpty()){
        throw std::runtime_error(std::string("Warning: CircularHeaderList "+name+" is empty. Cannot Get(i)."));
    }

    if(i<=0){
        throw std::runtime_error(std::string("Warning: The smallest number of input i of Get(i) shoule be >=1."));
    }

    int count = 1;
    CHLNode<CoefType, ExpType> *current_node = header->link;

    while((count != i) && (current_node != header)){
        current_node = current_node->link;
        count++;
    }

    if(current_node == header){
        throw std::runtime_error(std::string("Warning: "+std::to_string(i)+"th element is not found in CircularHeaderList."));
    }

    return current_node;
}

template <typename CoefType, typename ExpType>
int CircularHeaderList<CoefType, ExpType>::NumOfNodes(){
    if(IsEmpty()){
        return 0;
    }

    int count = 0;
    CHLNode<CoefType, ExpType> *current_node = header->link;

    while(current_node != header){
        current_node = current_node->link;
        count++;
    }

    return count;
}

template <typename CoefType, typename ExpType>
void CircularHeaderList<CoefType, ExpType>::operator=(const CircularHeaderList &other){
    header     = other.header;
    av         = other.av;
}

template <typename CoefType, typename ExpType>
std::ostream & operator<<(std::ostream &os, const CircularHeaderList<CoefType, ExpType> &out_list){
    if(out_list.IsEmpty()){
        throw std::runtime_error(std::string("Warning: Not available. The CircularHeaderList is empty."));
        return os;
    }

    CHLNode<CoefType, ExpType> *current_node = out_list.header->link;
    os<<out_list.name<<" = [";

    while(current_node != out_list.header){
        if(current_node->link == out_list.header){
            os<<"("<<current_node->coef<<", "<<current_node->exp<<")"<<"]"<<std::endl;
            break;
        }else{
            os<<"("<<current_node->coef<<", "<<current_node->exp<<")"<<" ";
        }
        current_node = current_node->link;
    }

    return os;
}

/*
template <typename CoefType, typename ExpType>
bool Polynomial<CoefType, ExpType>::SortFunction(const Term<CoefType, ExpType> &a, const Term<CoefType, ExpType> &b){
    return (a.exp > b.exp);
}
*/

